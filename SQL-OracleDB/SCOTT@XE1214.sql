-- 형변환 함수 : TO_NUMBER, TO_CHAR, TO_DATE
-- 1. DATE -> VARCHAR2 (날짜->문자)
SELECT SYSDATE FROM DUAL;
SELECT TO_CHAR(SYSDATE, 'YY-MM-DD HH24:MI:SS') FROM DUAL;

-- 2. NUMBER -> VARCHAR2 (숫자->문자)
SELECT ENAME, SAL FROM EMP;
SELECT ENAME, TO_CHAR(SAL, 'L999,999') FROM EMP; --'L' : LOCALE의 약어

-- 3. NUMBER -> DATE (숫자->날짜)
SELECT ENAME, HIREDATE FROM EMP;
SELECT ENAME, HIREDATE FROM EMP 
--WHERE HIREDATE='1981/02/20'; --문자열
WHERE HIREDATE = TO_DATE(19810220, 'YYYY-MM-DD');

-- 4. VARCHAR2 -> NUMBER (문자->숫자)
SELECT TO_NUMBER('20,000', '99,999') - TO_NUMBER('10,000','99,999') FROM DUAL;
----------------------------------------------------------------------------------------------
--그룹 쿼리와 집합 연산자

-- SUM : 합계
SELECT SUM(SAL) FROM EMP;
SELECT SUM(COMM) FROM EMP; --NULL값을 제외하고 합계를 구한다.

-- AVG : 평균
SELECT AVG(SAL) FROM EMP;
SELECT AVG(COMM) FROM EMP; --NULL값을 제외하고 평균을 구한다.

-- MAX, MIN : 최대, 최소
SELECT MAX(SAL), MIN(SAL) FROM EMP;
SELECT SAL FROM EMP;
SELECT ENAME, MAX(SAL) FROM EMP; --ORA-00937: not a single-group group function

-- COUNT : ROW 개수
SELECT COUNT(*), COUNT(COMM) FROM EMP;
SELECT COUNT(JOB)"업무수" FROM EMP; 
SELECT COUNT(DISTINCT JOB)"업무수" FROM EMP; --중복 제거
------------------------------------------------------------------------------------------------
-- SELECT (컬럼)
-- FROM (테이블) 
-- WHERE (조건)
-- ORDER BY (정렬)
-- GROUP BY (그룹핑)

-- GROUP BY 절
SELECT DEPTNO, AVG(SAL)
FROM EMP
GROUP BY DEPTNO; --그룹핑하여 평균 등 구할때 용이

SELECT DEPTNO, MAX(SAL), MIN(SAL)
FROM EMP
WHERE SAL>=800
GROUP BY DEPTNO
ORDER BY DEPTNO ASC;

-- HAVING 절 : GROUP에 대한 조건
SELECT DEPTNO, AVG(SAL)
FROM EMP
WHERE SAL>=800
GROUP BY DEPTNO
HAVING AVG(SAL) >= 2000
ORDER BY DEPTNO; 
---------------------------------------------------------------------------------
-- 집합 연산자
DROP TABLE EXP_GOODS_ASIA;
CREATE TABLE EXP_GOODS_ASIA (
COUNTRY VARCHAR2(10),
SEQ NUMBER,
GOODS VARCHAR2(80));
INSERT INTO EXP_GOODS_ASIA VALUES ('한국', 1, '원유제외 석유류');
INSERT INTO EXP_GOODS_ASIA VALUES ('한국', 2, '자동차');
INSERT INTO EXP_GOODS_ASIA VALUES ('한국', 3, '전자집적회로');
INSERT INTO EXP_GOODS_ASIA VALUES ('한국', 4, '선박');
INSERT INTO EXP_GOODS_ASIA VALUES ('한국', 5, 'LCD');
INSERT INTO EXP_GOODS_ASIA VALUES ('한국', 6, '자동차부품');
INSERT INTO EXP_GOODS_ASIA VALUES ('한국', 7, '휴대전화');
INSERT INTO EXP_GOODS_ASIA VALUES ('한국', 8, '환식탄화수소');
INSERT INTO EXP_GOODS_ASIA VALUES ('한국', 9, '무선송신기 디스플레이 부속품');
INSERT INTO EXP_GOODS_ASIA VALUES ('한국', 10, '철 또는 비합금강');
INSERT INTO EXP_GOODS_ASIA VALUES ('일본', 1, '자동차');
INSERT INTO EXP_GOODS_ASIA VALUES ('일본', 2, '자동차부품');
INSERT INTO EXP_GOODS_ASIA VALUES ('일본', 3, '전자집적회로');
INSERT INTO EXP_GOODS_ASIA VALUES ('일본', 4, '선박');
INSERT INTO EXP_GOODS_ASIA VALUES ('일본', 5, '반도체웨이퍼');
INSERT INTO EXP_GOODS_ASIA VALUES ('일본', 6, '화물차');
INSERT INTO EXP_GOODS_ASIA VALUES ('일본', 7, '원유제외 석유류');
INSERT INTO EXP_GOODS_ASIA VALUES ('일본', 8, '건설기계');
INSERT INTO EXP_GOODS_ASIA VALUES ('일본', 9, '다이오드, 트랜지스터');
INSERT INTO EXP_GOODS_ASIA VALUES ('일본', 10, '기계류');
COMMIT;
SELECT COUNT(*) FROM EXP_GOODS_ASIA;

SELECT GOODS
FROM EXP_GOODS_ASIA
WHERE COUNTRY = '한국'
ORDER BY SEQ;

SELECT GOODS
FROM EXP_GOODS_ASIA
WHERE COUNTRY = '일본'
ORDER BY SEQ;

-- UNION : 합집합 (A u B) : 중복을 제거하고 합한다
SELECT GOODS
FROM EXP_GOODS_ASIA
WHERE COUNTRY = '한국' 
--UNION --합집합 1.중복제거
--UNION ALL --합집합 2.중복포함
--INTERSECT --교집합
MINUS --차집합
SELECT GOODS
FROM EXP_GOODS_ASIA
WHERE COUNTRY = '일본';
------------------------------------------------------------------------
SELECT * FROM EMP;
SELECT * FROM DEPT;

SELECT DEPTNO FROM EMP
WHERE ENAME='SMITH';
SELECT DNAME FROM DEPT
WHERE DEPTNO=20;

-- JOIN
SELECT *
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO AND
EMP.ENAME = 'SMITH';

-- ORACLE CROSS JOIN
SELECT * 
FROM EMP, DEPT;

SELECT * FROM DEPT;
COMMIT;

DELETE FROM DEPT
WHERE DEPTNO=50;

-- ORACLE EQUIT JOIN
SELECT *
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO;

SELECT E.ENAME, D.DNAME, E.DEPTNO, D.DEPTNO
FROM EMP E, DEPT D -- 테이블에 별칭을 부여함
WHERE E.DEPTNO = D.DEPTNO
AND E.ENAME='SCOTT';

-- Non_Equi Join
SELECT * FROM SALGRADE;

SELECT E.ENAME, E.SAL, S.GRADE
FROM EMP E, SALGRADE S
--WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL; 
WHERE E.SAL >= S.LOSAL AND E.SAL <= S.HISAL; -- =BETWEEN S.LOSAL AND S.HISA

-- Self Join
SELECT EMPNO, ENAME, MGR FROM EMP;

SELECT E.ENAME"사원명", M.ENAME"상사명"
FROM EMP E, EMP M
WHERE E.MGR = M.EMPNO;
------------------------------------
--과제03
SELECT E.ENAME, E.JOB
FROM EMP E, EMP M
WHERE E.MGR = M.EMPNO 
AND M.ENAME='KING';

SELECT C.ENAME 
FROM EMP E, EMP C
WHERE E.DEPTNO = C.DEPTNO
AND E.ENAME = 'SCOTT'
AND C.ENAME <> 'SCOTT'
ORDER BY C.ENAME ASC;
---------------------------------------
--OTHER JOIN : 조인 조건에 만족하지 못하였더라도 해당 로우를 나타내려호 할 때 사용한다.
SELECT * FROM EMP;
SELECT E.ENAME, M.ENAME
FROM EMP E, EMP M
WHERE E.MGR = M.EMPNO(+);

-- ANSI CROSS JOIN = ORACLE CROSS JOIN
SELECT *
--FROM EMP, DEPT; --ORACLE에서만 사용하는 CROSS JOIN
FROM EMP CROSS JOIN DEPT; --ANSI(다른 DB에서 사용하는 CROSS JOIN)

-- ANSI INNER JOIN = OREACLE EQUI JOIN
SELECT E.ENAME, D.DNAME
--FROM EMP E, DEPT D --ORACLE에서만 사용한 EQUI JOIN
--WHERE E.DEPTNO = D.DEPTNO;
FROM EMP E INNER JOIN DEPT D --ANSI INNER JOIN
--ON E.DEPTNO = D.DEPTNO; --조건방법1
USING(DEPTNO); --조건방법2

-- ANSI NATURAL JOIN : 자동적으로 모든 컬럼을 대상으로 공통 컬럼을 조사하여 내부적으로 조인문을 생성
SELECT E.ENAME, D.DNAME
FROM EMP E NATURAL JOIN DEPT D;

-- ANSI OUTER JOIN
DROP TABLE DEPT01;
CREATE TABLE DEPT01(
DEPTNO NUMBER(2),
DNAME VARCHAR2(14)
);
INSERT INTO DEPT01 VALUES(10,'ACCOUNTING');
INSERT INTO DEPT01 VALUES(20,'RESEARCH');
SELECT * FROM DEPT01;
DROP TABLE DEPT02;
CREATE TABLE DEPT02(
DEPTNO NUMBER(2),
DNAME VARCHAR2(14)
);
INSERT INTO DEPT02 VALUES(10,'ACCOUNTING');
INSERT INTO DEPT02 VALUES(30,'SALES');
SELECT * FROM DEPT02;
-- ANSI Left Outer Join
SELECT *
FROM DEPT01 LEFT OUTER JOIN DEPT02
ON DEPT01.DEPTNO = DEPT02.DEPTNO;
-- ANSI Right Outer Join
SELECT *
FROM DEPT01 RIGHT OUTER JOIN DEPT02
USING(DEPTNO);
-- ANSI Full Outer Join
SELECT *
FROM DEPT01 FULL OUTER JOIN DEPT02
USING(DEPTNO);

----------------------------------------------------
--과제7-2
SELECT * FROM EMP;
SELECT E.ENAME, D.DNAME
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
AND E.JOB='MANAGER';

SELECT E.ENAME, D.DNAME
FROM EMP E INNER JOIN DEPT D
ON E.DEPTNO = D.DEPTNO
AND E.JOB='MANAGER';

SELECT E.ENAME, D.DNAME
FROM EMP E NATURAL JOIN DEPT D
WHERE E.JOB='MANAGER';

SELECT C.ENAME, C.JOB
FROM EMP E, EMP C
WHERE E.ENAME='SMITH'
AND E.JOB=C.JOB
AND C.ENAME!='SMITH';
