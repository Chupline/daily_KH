-- ORACLE OUTER JOIN
SELECT E.ENAME, M.ENAME
FROM EMP E, EMP M
WHERE E.MGR = M.EMPNO(+);

-- ANSI OUTER JOIN : 조인문이 왼쪽에 있는 테이블의 모든 결과를 가져온 후
-- 오른쪽 테이블의 테이터를 매칭하고, 매칭되는 데이터가 없는 경우 NULL로 표시한다.
SELECT E.ENAME, M.ENAME
FROM EMP E LEFT OUTER JOIN EMP M
ON E.MGR = M.EMPNO;
---------------------------------------------------------------------------------------------
-- 8강

-- 서브 쿼리
SELECT DNAME
FROM DEPT
WHERE DEPTNO = ( SELECT DEPTNO
                 FROM EMP
                 WHERE ENAME='SCOTT');                 
SELECT DNAME
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO
AND EMP.ENAME='SCOTT';

-- 단일행 서브 쿼리
SELECT ENAME, SAL
FROM EMP
WHERE SAL > (SELECT AVG(SAL)
             FROM EMP);
             
-- 다중행 서브 쿼리 : IN, ANY, SOM, ALL, EXIST

-- IN 연산자 : 서브 쿼리의 출력 결과 중에서 하나라도 일치하면 참이다.
SELECT ENAME, SAL, DEPTNO
FROM EMP
WHERE DEPTNO IN (SELECT DISTINCT DEPTNO
                 FROM EMP
                 WHERE SAL >= 3000);
-- ALL 연산자 : 서브 쿼리의 검색 결과와 모든 값이 일치하면 참이다.
SELECT ENAME, SAL
FROM EMP
WHERE SAL > ALL(SELECT SAL
                FROM EMP
                WHERE DEPTNO=30); --DEPNO=30 중 가장 큰 수(2850)와 비교
-- ANY 연산자 : 서브 쿼리의 검색 결과와 하나 이상만 일치하면 참이다.
SELECT ENAME, SAL
FROM EMP
WHERE SAL > ANY (SELECT SAL
                 FROM EMP
                 WHERE DEPTNO=30); --DEPTNO=30 중 가장 작은수(950)와 비교
-- EXISTS 연산자 : 서브 쿼리의 결과값이 하나이상 존재하면 메인 조건식이 모두 TRUE,
-- 존재하지 않으면 모두 FALSE가 되는 연산자
SELECT *
FROM EMP
WHERE 1=1;

SELECT *
FROM EMP
WHERE EXISTS (SELECT DNAME
              FROM DEPT
              WHERE DEPTNO=10); --서브쿼리 값이 참이면 값을 보여준다
    
SELECT * FROM EMP;
--과제8-2------------------------------
UPDATE EMP SET SAL =2850
WHERE ENAME='SMITH';

SELECT EMPNO, ENAME, SAL, DEPTNO
FROM EMP
WHERE (DEPTNO, SAL) IN(SELECT DEPTNO, MAX(SAL)
                    FROM EMP
                    GROUP BY DEPTNO)
ORDER BY DEPTNO ASC;
--------------------------------------
-- DDL : CREATE, ALTER, RENAME, TRUNCATE, DROP
-- DML : INSERT, UPDATE, DELETE, SELECT

--CREATE문
CREATE TABLE EX2_1 (
    COLUMN1 CHAR(10),
    COLUMN2 VARCHAR2(10),
    COLUMN3 VARCHAR2(10),
    COLUMN4 NUMBER
);
DESC EX2_1;
-- 테이블 생성
DROP TABLE EMP01 CASCADE CONSTRAINTS;
CREATE TABLE EMP01(
    EMPNO NUMBER(4),
    ENAME VARCHAR2(20),
    SAL NUMBER(7, 2)
);

SELECT * FROM EMP01;
DESC EMP01

-- 서브 쿼리로 테이블 생성하기
CREATE TABLE EMP02
AS
SELECT * FROM EMP;
DESC EMP02;
SELECT * FROM EMP02; --복사가 됨

-- 특정한 컬럼으로 구성된 복제 테이블 생성하기
CREATE TABLE EMP03
AS
SELECT EMPNO, ENAME FROM EMP; --EMPNO, ENAME 테이블생성하면서 복사
SELECT * FROM EMP03;

-- 원하는 행(ROW)으로 구성된 복제 테이블 생성하기
CREATE TABLE EMP05
AS
SELECT * FROM EMP
WHERE DEPTNO=10; --DEPT10 부분만 테이블 생성하면서 복사

-- 테이블 구조만 복사
CREATE TABLE EMP06
AS
SELECT * FROM EMP
WHERE 1=0;

-- ALTER TABLE
-- TABLE에 COLUMN추가
DESC EMP01;
ALTER TABLE EMP01
ADD(JOB VARCHAR2(9));

--기존 컬럼 속성 변경하기
ALTER TABLE EMP01
MODIFY(JOB VARCHAR2(30));
DESC EMP01

--기존 컬럼 삭제하기
ALTER TABLE EMP01
DROP COLUMN JOB;
DESC EMP01  

--SET UNUSED 옵션 적용하기
ALTER TABLE EMP02
SET UNUSED(JOB);
SELECT * FROM EMP02;
DESC EMP02;
ALTER TABLE EMP02
DROP UNUSED COLUMNS;

-- DROP TABLE : 테이블 삭제
DROP TABLE EMP01;
DROP TABLE EMP02;
DROP TABLE EMP01 CASCADE CONSTRAINTS;
SELECT * FROM EMP01;

SELECT * FROM EMP03;  
DELETE FROM EMP03;    --DML : DELETE 후 ROLLBACK하면 복구가 된다. 
ROLLBACK;
TRUNCATE TABLE EMP03; --DDL : TRUNCATE 후 ROLLBACK하면 복구가 안된다. (TRUNCATE = DELETE+COMMIT)

-- RENAME TABLE : 테이블 명 변경
RENAME EMP03 TO TEST;
SELECT * FROM TEST;

--스키마(SCHEMA)= USER(의 객체들)

-- USER_ 데이터 딕셔너리

DESC USER_TABLES;

SELECT TABLE_NAME FROM USER_TABLES
ORDER BY TABLE_NAME ASC;

SELECT * FROM DEPT;
SELECT * FROM SYSTEM.HELP; --원래 다른 계정의 테이블 접속되지않는다.

-- ALL_ 데이터 딕셔너리
DESC ALL_TABLES;
SELECT OWNER, TABLE_NAME FROM ALL_TABLES;

--SYS(SUPER)
--SYSTEM(DBA)

SHOW USER;
SELECT TABLE_NAME, OWNER FROM DBA_TABLES;


-----------------------------------------------
-- DML : INSERT, UPDATE, DELETE
-- INSERT문
DESC DEPT01;
ALTER TABLE DEPT01
ADD(LOC VARCHAR2(10));

INSERT INTO DEPT01 VALUES(10, 'ACCOUNTIN', 'NEW YOR');
SELECT * FROM DEPT01;
INSERT INTO DEPT01 VALUES(30, 'DEVELOPMENT', NULL);
INSERT INTO DEPT01(DEPTNO,DNAME) VALUES(40, 'SALES');

DROP TABLE DEPT01;
CREATE TABLE DEPT01
AS
SELECT * FROM DEPT WHERE 1=0;
SELECT * FROM DEPT01;